var f=function(t){module("global"),test("NEJ.C",function(){var n=t._$klass(),i=0;n.__static=function(){return"static"},n.prototype.__init=function(){i=10};var _=t._$klass(),e=_._$extend(n);e.__init=function(){this.__super(),i--};new n;equal(typeof n,"function","返回一个函数对象"),equal(typeof n._$bind,"function","返回的对象有_$bind方法,继承自Function"),equal(typeof n._$bind2,"function","返回的对象有_$bind2方法,继承自Function");new _;equal(i,9,"父类__init后，子类__init会被调用"),equal(_.__static(),"static","默认继承了静态方法，如不继承传入false参数")}),test("_$bind接口",function(){var n=t._$klass();n.prototype.__init=function(){};var i=t._$klass(),_=i._$extend(n);_.__print=function(t,n){return arguments[0]+arguments[1]},_.__init=function(){this.__super(),this.num=33;var t=this.__print._$bind(this,"obj"),n=this.__print._$bind2(this,"obj");equal(t("aaa"),"objaaa","测试_$bind方法,参数的顺序调用"),equal(n("bbb"),"bbbobj","测试_$bind2方法,参数的倒序调用")};new i})};module("依赖模块"),test("define",function(){expect(0),define("{pro}global.test.js",["{lib}base/klass.js"],f)});